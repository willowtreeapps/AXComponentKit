{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/AXComponentKitTestSupport\/documentation\/AXComponentKitTestSupport\/AXScreenNavigator"},{"type":"text","text":" is the foundational building block for handling navigation in a UI automation test. The navigator itself is generic and takes an "},{"type":"codeVoice","code":"AXScreenModel"},{"type":"text","text":", which acts as its source. Declaring a new navigator for the first tab screen in our sample app looks like this:"}]},{"type":"codeListing","syntax":"swift","code":["let navigator = AXScreenNavigator<FirstTabScreen>()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We usually read this as “A navigator starting at FirstTabScreen.” Alternatively, "},{"type":"codeVoice","code":"AXComponentKit"},{"type":"text","text":" includes a typealias on "},{"type":"codeVoice","code":"AXScreen"},{"type":"text","text":" that makes it possible to get the navigator for a given screen like this:"}]},{"type":"codeListing","syntax":"swift","code":["let navigator = FirstTabScreen.Navigator() \/\/ AXScreenNavigator<FirstTabScreen>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Most places create navigator instances in this way because it’s more concise, but both are valid constructions that mean the same thing."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A navigator allows the test runner to begin at the source screen and perform some operation to move to a destination screen. Here’s an example from our sample app that starts at the first tab’s screen and navigates to the second tab:"}]},{"type":"codeListing","syntax":"swift","code":["try await FirstTabScreen.navigate(toTab: \\.second)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Every operation that a navigator can perform returns a new navigator instance for the destination screen. This is where navigator composition becomes really powerful, as seen here, where we move to the second tab and then immediately navigate to the third item in the list:"}]},{"type":"codeListing","syntax":"swift","code":["try await FirstTabScreen.navigate(toTab: \\.second) \/\/ AXScreenNavigator<SecondTabScreen>","                        .navigate(toItem: 3)       \/\/ AXScreenNavigator<DetailScreen>"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In some places we refer to this as “chaining,” as we’re chaining together consecutive operations into one large navigation task."}]}],"type":"aside","name":"Note"},{"anchor":"Adding-New-Navigator-Operations","level":3,"type":"heading","text":"Adding New Navigator Operations"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Adding new operations to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/AXComponentKitTestSupport\/documentation\/AXComponentKitTestSupport\/AXScreenNavigator"},{"type":"text","text":" is similar to how we add capabilities to "},{"type":"codeVoice","code":"AXScreenModel"},{"type":"text","text":"s. Protocol extensions allow us to add operations to navigators that have a specific source screen. This means that operations we define for "},{"type":"codeVoice","code":"SecondTabScreen"},{"type":"text","text":" cannot show up on a navigator that starts on "},{"type":"codeVoice","code":"FirstTabScreen"},{"type":"text","text":". Here’s an example of how a new navigator extension is declared:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Swift < 5.7","extension AXScreenModel where Source == SecondTabScreen {","    ...","}","","\/\/ Swift 5.7+","extension AXScreenModel<SecondTabScreen> {","    ...","}"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"For the sake of compatability and better compile times, we use pre-5.7 Swift syntax."}]}],"type":"aside","name":"Note"},{"style":"warning","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"When adding new "},{"type":"codeVoice","code":"AXScreenNavigator"},{"type":"text","text":" extensions, be sure they are being added to your UI testing target ONLY. "},{"type":"codeVoice","code":"AXScreenNavigator"},{"type":"text","text":" relies on the "},{"type":"codeVoice","code":"XCTest"},{"type":"text","text":" framework, which is not available for standard application code."}]}],"type":"aside","name":"Warning"},{"anchor":"Fundamentals","level":5,"type":"heading","text":"Fundamentals"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Adding a new operation inside these extensions involves a decent amount of boilerplate that can be a lot to digest. Here’s a quick primer on what all those pieces are, taken directly from the function we used above (but omitting the good stuff for now):"}]},{"type":"codeListing","syntax":"swift","code":["extension AXScreenNavigator where Source == SecondTabScreen {","    @discardableResult                                                   \/\/ 1","    func navigate(","        toItem index: Int,                                               \/\/ 2","        file: StaticString = #file,                                      \/\/ 3","        line: UInt = #line","    ) async throws -> AXScreenNavigator<DetailScreen> {                  \/\/ 4, 5","        try await performNavigation(file: file, line: line) { _ in  \/\/ 6","            \/\/ TODO: Interact with the app","        }","    }","}"]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"@discardableResult"},{"type":"text","text":" allows us to invoke a chain of navigators without Swift forcing us to do something with the last navigator in the chain. Without it, we would have to write something like "},{"type":"codeVoice","code":"_ = SecondTabScreen.Navigator().performNavigation(toItem: 3)"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Instead, "},{"type":"codeVoice","code":"@discardableResult"},{"type":"text","text":" lets us ignore the fact that the function returned anything at all: "},{"type":"codeVoice","code":"SecondTabScreen.Navigator().performNavigation(toItem: 3)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The element we’re going to navigate to is an "},{"type":"codeVoice","code":"AXDynamicComponent<Int>"},{"type":"text","text":", so we need to know the value in order to locate the correct row and tap on it. We’ll ignore this for now since we’re going to focus on the actual test interactions down below."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"AXComponentKit has "},{"type":"codeVoice","code":"file"},{"type":"text","text":" and "},{"type":"codeVoice","code":"line"},{"type":"text","text":" parameters tacked onto nearly every function. We recommend you pay it forward and keep these in your functions as well. When an "},{"type":"codeVoice","code":"XCTFail"},{"type":"text","text":" or assertion occurs down deeper in the framework, these ensure that the correct file and line number are reported as the source of failure."},{"type":"text","text":" "},{"type":"text","text":"In practical terms, this means that an assertion failure down deep in "},{"type":"codeVoice","code":"AXComponentKit"},{"type":"text","text":" will report as a failure all the way up at the call site in your "},{"type":"codeVoice","code":"XCTestCase"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"insert picure"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Practically all navigator operations are "},{"type":"codeVoice","code":"async"},{"type":"text","text":" in nature because they wait for the source\/destination screens to exist, and for elements to become available. Since those tasks are asynchronous, all of our navigation operations that use then must also be asynchronous. In practice, this makes for cleaner code in test cases because it becomes much clearer "},{"type":"emphasis","inlineContent":[{"type":"text","text":"which"}]},{"type":"text","text":" operations are going to involve the passage of time."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If you are new to Swift or structured concurrency, this is what necessitates the "},{"type":"codeVoice","code":"await"},{"type":"text","text":" when calling async functions. The Swift "},{"type":"reference","isActive":true,"identifier":"https:\/\/docs.swift.org\/swift-book\/LanguageGuide\/Concurrency.html"},{"type":"text","text":" on concurrency is a great resource for more info."}]}],"type":"aside","name":"Note"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"throws"},{"type":"text","text":" is similar to the "},{"type":"codeVoice","code":"async"},{"type":"text","text":" keyword in that nature of the functions our navigation operations are dependent on, most of those functions are also capable of throwing an error when a failure occurs. This is important because test execution won’t "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/xctest\/xctestcase\/1496260-continueafterfailure"},{"type":"text","text":" stop executing simply because an assertion fails at some point in your test. By throwing when an error occurs, we have an escape hatch to abort when an expected condition is not satisfied and guarantee that the test case will not continue."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"performNavigation(...)"},{"type":"text","text":" should be present in all navigator operations because it handles the assertions around source\/destination screen existence. The function returns the destination navigator when that screen appears, and Swift’s implicit return values + type inference make calling the function more succinct than it would be if we wrote out everything fully:"}]}]}]},{"type":"codeListing","syntax":"swift","code":["extension AXScreenNavigator where Source == SecondTabScreen {","    @discardableResult","    func navigate(","        toItem index: Int,","        file: StaticString = #file,","        line: UInt = #line","    ) async throws -> AXScreenNavigator<DetailScreen> {","        return try await performNavigation(to: DetailScreen.self, file: file, line: line) { _ in","            \/\/ TODO: Interact with the app","        }","    }","}"]},{"anchor":"Xcode-Code-Snippet","level":5,"type":"heading","text":"Xcode Code Snippet"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once you understand the fundamentals of a navigator operation, you can start building your own extensions. If you find yourself making these often (you should!), then we encourage "},{"type":"reference","isActive":true,"identifier":"https:\/\/sarunw.com\/posts\/how-to-create-code-snippets-in-xcode\/"},{"type":"text","text":" as an Xcode snippet:"}]},{"type":"codeListing","syntax":"swift","code":["extension AXScreenNavigator where Source == <#Source#> {","    @discardableResult","    func navigate(","        file: StaticString = #file,","        line: UInt = #line","    ) async throws -> AXScreenNavigator<<#Destination#>> {","        try await performNavigation(file: file, line: line) { screen in","            <#Body#>","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It will help make the boilerplate a breeze!"}]},{"anchor":"Functionality","level":5,"type":"heading","text":"Functionality"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The body and parameters of your navigation function can be practically anything needed to help make your test execution steps as succinct and atomic as possible. Let’s look at the full example we started with from our example project. You’ll see that it’s actually pretty lean:"}]},{"type":"codeListing","syntax":"swift","code":["extension AXScreenNavigator where Source == SecondTabScreen {","    @discardableResult","    func navigate(","        toItem ordinal: Int,","        file: StaticString = #file,","        line: UInt = #line","    ) async throws -> AXScreenNavigator<DetailScreen> {","        try await performNavigation(file: file, line: line) { screen in","            try await scroll(to: \\.rowItem, value: ordinal, in: \\.table, file: file, line: line)","            let rowItem = try await screen.element(\\.rowItem, value: ordinal, file: file, line: line)","            rowItem.tap()","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Since navigation operations are atomic, we are assured that we’re on the source screen. We can focus on any and all factors that might affect the success of this operation, and ensure that it’s equipped to succeed. In this example, there is no limit on the value that can be passed for "},{"type":"codeVoice","code":"ordinal"},{"type":"text","text":", so we must first guarantee we can scroll down to find it in the event that the element is offscreen."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"These kinds of guarantees can be difficult. What if the screen is somehow scrolled down already when this executes? As written, we don’t have a way to deal with that. Most of the time we simply don’t have enough information to know which direction we should scroll based on what is currently visible. Perhaps a future version of the framework will allow us to be more intelligent about this, but for now we can only move in a prescribed direction."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/axcomponentkittestsupport\/navigators"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/AXComponentKitTestSupport\/documentation\/AXComponentKitTestSupport\/Navigators","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"How to make tests move from one place to another"}],"kind":"article","metadata":{"roleHeading":"Article","title":"Navigators","role":"article","modules":[{"name":"AXComponentKitTestSupport"}]},"hierarchy":{"paths":[["doc:\/\/AXComponentKitTestSupport\/documentation\/AXComponentKitTestSupport"]]},"references":{"https://sarunw.com/posts/how-to-create-code-snippets-in-xcode/":{"title":"adding this","titleInlineContent":[{"type":"text","text":"adding this"}],"type":"link","identifier":"https:\/\/sarunw.com\/posts\/how-to-create-code-snippets-in-xcode\/","url":"https:\/\/sarunw.com\/posts\/how-to-create-code-snippets-in-xcode\/"},"doc://AXComponentKitTestSupport/documentation/AXComponentKitTestSupport/AXScreenNavigator":{"role":"symbol","title":"AXScreenNavigator","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AXScreenNavigator"}],"abstract":[{"type":"text","text":"Provides a composable interface for navigating between screens of content"}],"identifier":"doc:\/\/AXComponentKitTestSupport\/documentation\/AXComponentKitTestSupport\/AXScreenNavigator","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AXScreenNavigator"}],"url":"\/documentation\/axcomponentkittestsupport\/axscreennavigator"},"doc://AXComponentKitTestSupport/documentation/AXComponentKitTestSupport":{"role":"collection","title":"AXComponentKitTestSupport","abstract":[{"type":"text","text":"Writing your first UI test"}],"identifier":"doc:\/\/AXComponentKitTestSupport\/documentation\/AXComponentKitTestSupport","kind":"symbol","type":"topic","url":"\/documentation\/axcomponentkittestsupport"},"https://developer.apple.com/documentation/xctest/xctestcase/1496260-continueafterfailure":{"title":"necessarily","titleInlineContent":[{"type":"text","text":"necessarily"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/xctest\/xctestcase\/1496260-continueafterfailure","url":"https:\/\/developer.apple.com\/documentation\/xctest\/xctestcase\/1496260-continueafterfailure"},"https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html":{"title":"documentation","titleInlineContent":[{"type":"text","text":"documentation"}],"type":"link","identifier":"https:\/\/docs.swift.org\/swift-book\/LanguageGuide\/Concurrency.html","url":"https:\/\/docs.swift.org\/swift-book\/LanguageGuide\/Concurrency.html"}}}