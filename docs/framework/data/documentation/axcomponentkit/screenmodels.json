{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The Screen Model is a container for components that exist within “a screen full” of content. This would usually be something like a tab within your tab bar, or a single level within a navigation stack. Most of the examples for this guide reference code directly from the "},{"type":"codeVoice","code":"AXComponentKitSample"},{"type":"text","text":" app, which is bundled in the package repo."}]},{"anchor":"Creating-a-Model","level":2,"type":"heading","text":"Creating a Model"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Screen models in "},{"type":"codeVoice","code":"AXComponentKit"},{"type":"text","text":" rely heavily on protocols. For something to be “a screen,” the only requirement is that it conforms to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/AXComponentKit\/documentation\/AXComponentKit\/AXScreen"},{"type":"text","text":". Additional protocols can (and should!) be created as part of your test target that allow your screen to adopt additional capabilities. More on that "},{"type":"emphasis","inlineContent":[{"type":"text","text":"here"}]},{"type":"text","text":" (link)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here is how we define the initial screen in our sample app, without any of its components, and without satisfying the requirements of "},{"type":"reference","isActive":true,"identifier":"doc:\/\/AXComponentKit\/documentation\/AXComponentKit\/AXScreen"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["struct FirstTabScreen: AXScreen {","    \/\/ TODO: Fulfill protocol requirements","}"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"type":"reference","isActive":true,"identifier":"doc:\/\/AXComponentKit\/documentation\/AXComponentKit\/AXScreen"},{"type":"text","text":" requires an "},{"type":"codeVoice","code":"init()"},{"type":"text","text":" initializer, which is synthesized by the compiler automatically if all properties have an initial default value. All screen models in the sample project rely on the compiler to provide this initializer."}]}],"type":"aside","name":"Note"},{"anchor":"Screen-Identifiers","level":3,"type":"heading","text":"Screen Identifiers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"From a test automation perspective, being able to ask the question “what screen is currently visible?” instead of simply “what elements are currently visible?” is quite useful. It provides clearer guarantees about the state of the app under test, and allows more descriptive diagnostic errors to surface when an expected screen doesn’t show up."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To facilitate this, every screen model must provide a "},{"type":"codeVoice","code":"screenIdentifier"},{"type":"text","text":" that should uniquely identify that screen. As of now, these are static identifiers and there is not a mechanism for dynamic variation in the spirit of "},{"type":"reference","isActive":true,"identifier":"doc:\/\/AXComponentKit\/documentation\/AXComponentKit\/AXComponent"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Fulfilling this requirement for our example screen looks something like this:"}]},{"type":"codeListing","syntax":"swift","code":["struct FirstTabScreen: AXScreen {","    static let screenIdentifier = \"first-tab-screen\"","}"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"There is currently no mechanism to ensure that all screens are identified uniquely, so choose a naming scheme that can scale over time!"}]}],"type":"aside","name":"Note"},{"anchor":"Defining-Components","level":2,"type":"heading","text":"Defining Components"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A screen on its own is not very useful without components! Fortunately, they are easy to add. There are a few types of components to choose from for different use cases, so we’ll cover them one by one."}]},{"anchor":"Static-Components","level":3,"type":"heading","text":"Static Components"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The most common component is "},{"type":"reference","isActive":true,"identifier":"doc:\/\/AXComponentKit\/documentation\/AXComponentKit\/AXComponent"},{"type":"text","text":", which allows a static identifier to be specified for a view in your app. "},{"type":"reference","isActive":true,"identifier":"doc:\/\/AXComponentKit\/documentation\/AXComponentKit\/AXComponent"},{"type":"text","text":" should be used in situations where you have an element on screen that does not get reused and does not change its identity at any point during the screen’s lifecycle. For example, the countdown timer label in a timer app."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here is the recommended syntax for defining a button component on the example screen from above. This button is fixed in the middle of the screen and does not change:"}]},{"type":"codeListing","syntax":"swift","code":["struct FirstTabScreen: AXScreen {","    static let screenIdentifier = \"first-tab-screen\"","","    let detailButton: AXComponent = \"first-tab-screen-detail-button\"","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"All component types take advantage of the "},{"type":"codeVoice","code":"ExpressibleByStringLiteral"},{"type":"text","text":" protocol, so they can be defined inline with this concise syntax."}]},{"anchor":"Dynamic-Components","level":3,"type":"heading","text":"Dynamic Components"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Static components don’t work well for situations where identifiers should really reflect the dynamic nature of the content they’re associated with. For these situations, "},{"type":"reference","isActive":true,"identifier":"doc:\/\/AXComponentKit\/documentation\/AXComponentKit\/AXDynamicComponent"},{"type":"text","text":" provides a straightforward means to dynamically construct identifiers at runtime, but in a type-safe way."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A dynamic component uses the string literal provided at its declaration as a prefix for its identifier. The dynamic value is later stringified and concatenated. An example of the result is below."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example from our sample app of a dynamic component from the Second Tab screen:"}]},{"type":"codeListing","syntax":"swift","code":["struct SecondTabScreen: AXScreen {","    static let screenIdentifier = \"second-tab-screen\"","","    let rowItem: AXDynamicComponent<Int> = \"second-tab-dynamic-row\"","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As you can see, "},{"type":"codeVoice","code":"AXDynamicComponent<Value>"},{"type":"text","text":" is generic and allows the consumer to specify what "},{"type":"codeVoice","code":"Value"},{"type":"text","text":" actually is. This means that dynamic components can take any type of data you want to provide them."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example, the component takes an "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" because the identifier is derived from the index its row in the list, making each row unique in the eyes of the test runner. Generated identifiers for "},{"type":"codeVoice","code":"rowItem"},{"type":"text","text":" look like this at runtime:"}]},{"type":"codeListing","syntax":null,"code":["second-tab-dynamic-row-0","second-tab-dynamic-row-1","second-tab-dynamic-row-2"]},{"anchor":"Default-Types","level":4,"type":"heading","text":"Default Types"},{"type":"paragraph","inlineContent":[{"type":"text","text":"By default, "},{"type":"reference","isActive":true,"identifier":"doc:\/\/AXComponentKit\/documentation\/AXComponentKit\/AXDynamicComponent"},{"type":"text","text":" has support for Swift’s signed and unsigned integer types, as well as strings. "},{"type":"codeVoice","code":"AXComponentKit"},{"type":"text","text":" can add support for more native types over time, but these cover most of the common use cases."}]},{"anchor":"Custom-Types","level":4,"type":"heading","text":"Custom Types"},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/AXComponentKit\/documentation\/AXComponentKit\/AXDynamicComponent"},{"type":"text","text":" can also support identifiers that are generated based on custom types not natively supported by "},{"type":"codeVoice","code":"AXComponentKit"},{"type":"text","text":". Custom types that conform to the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/AXComponentKit\/documentation\/AXComponentKit\/AXDynamicValue"},{"type":"text","text":" protocol can work just as effortlessly as the default types listed above."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here is an example of a custom type being defined and used in a contrived example:"}]},{"type":"codeListing","syntax":"swift","code":["enum Animal: String {","    case lion","    case tiger","    case bear","}","","extension Animal: AXDynamicValue {","    var automationDynamicValue: String { ","        self.rawValue","    }","}","","struct ZooScreen: AXScreen {","    static let screenIdentifier = \"this-screen-is-a-zoo\"","","    let animalRow: AXDynamicComponent<Animal> = \"second-tab-animal-row\"","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Generated identifiers for "},{"type":"codeVoice","code":"animalRow"},{"type":"text","text":" would look like this at runtime:"}]},{"type":"codeListing","syntax":null,"code":["second-tab-animal-row-lion","second-tab-animal-row-tiger","second-tab-animal-row-bear"]},{"anchor":"Scroll-Views","level":3,"type":"heading","text":"Scroll Views"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Scroll views are a special case to enhance test reliability. When interacting with scrolling content, test runners often have to make assumptions about which scroll view they are interacting with, and where it exists on screen. Furthermore, querying for different kinds of scroll views in a generic way can be cumbersome because "},{"type":"codeVoice","code":"XCUIElementQuery"},{"type":"text","text":" does not consider table and collection views to be “scroll views.”"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To address this, "},{"type":"codeVoice","code":"AXComponentKit"},{"type":"text","text":" prefers explicit declaration of scroll views to ensure the intended view is being scrolled while running tests. An example of this can be seen on the second tab screen:"}]},{"type":"codeListing","syntax":null,"code":["struct SecondTabScreen: AXScreen {","    static let screenIdentifier = \"second-tab-screen\"","","    let table: AXScrollView = \"second-table-table-view\"","}"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"AXScrollView"},{"type":"text","text":" is used to designate a container and for aiding in scrolling. Scroll views cannot be directly queried like other components from the test runner."}]},{"anchor":"Shared-Components","level":3,"type":"heading","text":"Shared Components"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In many iOS Page Object Model architectures, it is common to have a "},{"type":"codeVoice","code":"BaseScreen"},{"type":"text","text":" class that all screen models inherit from. This provides a convenient way for shared identifiers to proliferate to all screens, but it can easily become a dumping ground for accessibility identifiers that are not "},{"type":"emphasis","inlineContent":[{"type":"text","text":"actually"}]},{"type":"text","text":" accessible on all screens all the time."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To combat this, we recommend approaching shared elements through protocol composition. One can define a “Capability” that a screen model can adopt:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Declare a protocol for the new capability","protocol BottomToolbarNavigable { }","","\/\/ Add default components in a protocol extension","extension BottomToolbarNavigable {","","    \/\/ Protocol extensions must not store any state, so","    \/\/ anything added must be a computed property","    var toolbarButtonLeading: AXComponent { ","        \"bottom-toolbar-button-leading\" ","    }","}","","\/\/ Add this capability to one or more screens","extension FirstScreen: BottomToolbarNavigable { }","extension SecondScreen: BottomToolbarNavigable { }","extension ThirdScreen: BottomToolbarNavigable { }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you find yourself with many screens that share the same capabilities, consider making a single protocol that unifies them:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Define a protocol that encompasses an overall flow","protocol ToolbarFlowScreen: AXScreen, BottomToolbarNavigable { }","","\/\/ Adopt that protocol in your screens instead of AXScreen","struct FirstScreen: ToolbarFlowScreen { ","    ...","}","","struct SecondScreen: ToolbarFlowScreen { ","    ...","}","","struct ThirdScreen: ToolbarFlowScreen { ","    ...","}"]},{"anchor":"System-Components","level":3,"type":"heading","text":"System Components"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The system UI frameworks do not always provide an API for assigning accessibility identifiers to views. For example, tab bars handle their own accessibility configuration and do not allow specific identifiers to be associated with tab bar items."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In order for these elements to work seamlessly in a unified API with "},{"type":"codeVoice","code":"AXComponentKit"},{"type":"text","text":", we recommend treating these as capabilities (see above). For capabilities that provide access to system elements such as a tab bar, it should be preferred to build upon AXComponentKit primitives (or contribute new ones to AXComponentKit if not already present). For the tab bar example, see "},{"type":"codeVoice","code":"AXTabBarNavigable"},{"type":"text","text":" and "},{"type":"codeVoice","code":"AXTabComponent"},{"type":"text","text":" in "},{"type":"codeVoice","code":"AXComponentKitTestSupport"},{"type":"text","text":". Together, these allow our sample app’s test target to declare "},{"type":"codeVoice","code":"RootTabBarNavigable"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["protocol RootTabBarNavigable: AXTabBarNavigable {}","","extension RootTabBarNavigable {","    var first: AXTabComponent<FirstTabScreen> {","        .init(name: \"First\")","    }","","    var second: AXTabComponent<SecondTabScreen> {","        .init(name: \"Second\")","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"AXTabBarNavigable"},{"type":"text","text":" provides a means to handle special-case navigation to these components, while "},{"type":"codeVoice","code":"AXTabComponent"},{"type":"text","text":" provides a means of defining what a tab component is and what destination screen that tab contains. This makes the actual lift of adding a system capability to your application code base much lower than it otherwise would’ve been."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/axcomponentkit\/screenmodels"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/AXComponentKit\/documentation\/AXComponentKit\/ScreenModels","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"How to add screen models to your project"}],"kind":"article","metadata":{"roleHeading":"Article","title":"Setting Up Screen Models","role":"article","modules":[{"name":"AXComponentKit"}]},"hierarchy":{"paths":[["doc:\/\/AXComponentKit\/documentation\/AXComponentKit"]]},"references":{"doc://AXComponentKit/documentation/AXComponentKit/AXScreen":{"role":"symbol","title":"AXScreen","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"AXScreen"}],"abstract":[{"type":"text","text":"Defines a logical screen that acts as a page model during testing"}],"identifier":"doc:\/\/AXComponentKit\/documentation\/AXComponentKit\/AXScreen","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AXScreen"}],"url":"\/documentation\/axcomponentkit\/axscreen"},"doc://AXComponentKit/documentation/AXComponentKit/AXDynamicComponent":{"role":"symbol","title":"AXDynamicComponent","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AXDynamicComponent"}],"abstract":[{"type":"text","text":"Defines a logical automation component that can exist within"},{"type":"text","text":" "},{"type":"text","text":"an application’s view hierarchy. This represents an element with"},{"type":"text","text":" "},{"type":"text","text":"a partial identifier that gets supplemented at runtime with a generic"},{"type":"text","text":" "},{"type":"text","text":"value."}],"identifier":"doc:\/\/AXComponentKit\/documentation\/AXComponentKit\/AXDynamicComponent","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AXDynamicComponent"}],"url":"\/documentation\/axcomponentkit\/axdynamiccomponent"},"doc://AXComponentKit/documentation/AXComponentKit/AXDynamicValue":{"role":"symbol","title":"AXDynamicValue","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"AXDynamicValue"}],"abstract":[{"type":"text","text":"Defines a generic means of making any type not"},{"type":"text","text":" "},{"type":"text","text":"supported by default into a value compatible with"},{"type":"text","text":" "},{"type":"codeVoice","code":"AXDynamicComponent"}],"identifier":"doc:\/\/AXComponentKit\/documentation\/AXComponentKit\/AXDynamicValue","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AXDynamicValue"}],"url":"\/documentation\/axcomponentkit\/axdynamicvalue"},"doc://AXComponentKit/documentation/AXComponentKit":{"role":"collection","title":"AXComponentKit","abstract":[{"type":"text","text":"Modular UI testing framework abstraction that works in concert with XCTest"}],"identifier":"doc:\/\/AXComponentKit\/documentation\/AXComponentKit","kind":"symbol","type":"topic","url":"\/documentation\/axcomponentkit"},"doc://AXComponentKit/documentation/AXComponentKit/AXComponent":{"role":"symbol","title":"AXComponent","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AXComponent"}],"abstract":[{"type":"text","text":"Defines a logical automation component that can exist within"},{"type":"text","text":" "},{"type":"text","text":"an application’s view hierarchy. This represents an element with"},{"type":"text","text":" "},{"type":"text","text":"a fully qualified identifier, be it a static element that is predefined,"},{"type":"text","text":" "},{"type":"text","text":"or the result of resolving an "},{"type":"codeVoice","code":"AXDynamicComponent"},{"type":"text","text":" with some value."}],"identifier":"doc:\/\/AXComponentKit\/documentation\/AXComponentKit\/AXComponent","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AXComponent"}],"url":"\/documentation\/axcomponentkit\/axcomponent"}}}